---
title: "Hindi: Language Experience Clustering"
output: html_document
---
## Packages & Functions
```{r}
library(tidyverse)
library(mgsub)
library(ggplot2)
# library(viridis)
library(RColorBrewer)

# Create tables
library(gt)
library(webshot)
library(xtable)

# Clustering
library(cluster)
library(factoextra)
library(NbClust)
library(fpc)
library(dendextend)

library(corrplot)

gg_theme <- function() {
  theme_bw() +
  theme(plot.title=element_text(size=25),
        plot.subtitle=element_text(size=15, face="italic"),
        axis.title=element_text(size=20),
        axis.text=element_text(size=15),
        strip.background =element_rect(fill="white"),
        strip.text = element_text(size=15))+
  theme(legend.title = element_text(size=15, face="bold"),
        legend.text=element_text(size=10))
}

get.rgb <- function(col, alpha=0.1) {
  if(missing(col))
    stop("Please provide a colour.")
  rgbcol <- col2rgb(col)/255
  rgb(rgbcol[1], rgbcol[2], rgbcol[3], alpha=alpha)
}
```

## Specifying Dendrogram Info
```{r}
# Brewer pallette options
## Sequential
RColorBrewer::display.brewer.pal(4, "OrRd") ###
RColorBrewer::display.brewer.pal(4, "YlOrBr") ###
RColorBrewer::display.brewer.pal(4, "YlGnBu") ###


## Qualitative
RColorBrewer::display.brewer.pal(4, "Set2")
RColorBrewer::display.brewer.pal(4, "Paired")
RColorBrewer::display.brewer.pal(4, "Dark2")

## Diverging (light in the middle)
RColorBrewer::display.brewer.pal(4, "BrBG")
# RColorBrewer::display.brewer.pal(4, "RdGy")
RColorBrewer::display.brewer.pal(4, "RdBu")
RColorBrewer::display.brewer.pal(4, "PuOr")
RColorBrewer::display.brewer.pal(4, "PiYG")
RColorBrewer::display.brewer.pal(4, "PRGn")

# RColorBrewer::display.brewer.pal(4, "RdYlGn")
RColorBrewer::display.brewer.pal(4, "RdYlBu")

# RColorBrewer::display.brewer.pal(4, "Spectral")

```
```{r}
# Create a vector of colors
native_colors_list <- c("both", "Eng", "HU", "neither              ") %>% 
  cbind(c(brewer.pal(4, "YlGnBu")[4],
          brewer.pal(4, "YlGnBu")[3],
          brewer.pal(4, "YlGnBu")[2],
          brewer.pal(4, "YlGnBu")[1]))

residence_colors_list <- c("SouthAs", "SAtoNA", "NorthAm", "uncategorized") %>% 
  cbind(c(brewer.pal(4, "YlOrBr")[4],
          brewer.pal(4, "YlOrBr")[3],
          brewer.pal(4, "YlOrBr")[2],
          brewer.pal(4, "YlOrBr")[1]))

native_colors <- case_when(
  hindi_groups$native_group=="both" ~ brewer.pal(4, "YlGnBu")[4], 
  hindi_groups$native_group=="Eng" ~ brewer.pal(4, "YlGnBu")[3],
  hindi_groups$native_group=="HU" ~ brewer.pal(4, "YlGnBu")[2], 
  hindi_groups$native_group=="neither" ~ brewer.pal(4, "YlGnBu")[1], 
  TRUE ~ "white") #cornflowerblue, chocolate2

residence_colors <- case_when(
  hindi_groups$residence_group=="SouthAs" ~ brewer.pal(4, "YlOrBr")[4], 
  hindi_groups$residence_group=="SAtoNA" ~ brewer.pal(4, "YlOrBr")[3],
  hindi_groups$residence_group=="NorthAm" ~ brewer.pal(4, "YlOrBr")[2], 
  TRUE ~ brewer.pal(4, "YlOrBr")[1]) 
```
## Load in Data
```{r}
load(file="data/processed/hindi.RData")
load(file="data/processed/hindi_subj.RData")
load(file="data/processed/hindi_groups.RData")
```

# .
## Pre-Clustering
### Stage 1: Select Clustering Variables

#### Prepare Dataframe
```{r}
hindi_langexp <- hindi %>% select(participant, hear_child:comfort_speak) %>% distinct()
hindi_langexp
```

#### Check Multicollinearity

Two highly correlated variables (over .9) to collapse: `comfort_read` & `comfort_write`

```{r}
# Create correlation matrix
hindi_langexp_cor <- cor(hindi_langexp %>% select(-participant), method="pearson") #method="spearman")
hindi_langexp_cor %>% as_tibble(rownames = "var") # independent variables correlation matrix 

# Visualize
corrplot::corrplot(hindi_langexp_cor,method='number',is.corr = T)
```

```{r}
# Modify dataframe to average multicolliear variables
hindi_langexp <- hindi_langexp %>%
  mutate(comfort_readwrite = (comfort_read+comfort_write)/2) %>% # take average
  select(-comfort_read, -comfort_write)
hindi_langexp
```

### Stage 2: Research Design

#### Sample Size
* Is the sample (large enough to be) representative?
* What is the smallest number of cases per cluster that will represent meaningful segments of the population?

```{r}
# A cluster size representing 10% of the sample
count(hindi_langexp) %>% mutate(tenpercent = n * 0.10)
```


#### Standardize Variables
* Choose to standardize or not?
* If standardize, z-scores (center and scale SD) or just mean center (center mean on 0, but leave SD)?

```{r}
langexp_scores <- hindi_langexp %>% select(-participant)
langexp_scores

# Mean-centered only (CENTERED)
langexp_centered <- as.data.frame(lapply(langexp_scores, scale, center=TRUE, scale=FALSE))
langexp_centered

# Z-scored (SCALED)
langexp_scaled <- as.data.frame(lapply(langexp_scores, scale))
langexp_scaled
```


#### Check for Outliers

* Use the Mahalanobis distance to assess outliers via visual inspection and selecting a threshold cut-off

```{r}
# Finding the center point 
langexp.center  = colMeans(langexp_scores)

# Finding the covariance matrix
langexp.cov     = cov(langexp_scores)

# Calculate Mahalnobis distance + identify outliers
hindi_mdist <- hindi_subj %>% 
  cbind(m_dist = mahalanobis(langexp_scores, 
                             langexp.center, langexp.cov)) %>%
  select(participant, m_dist)
  # mutate(outlier = ifelse(m_dist > 31, TRUE, FALSE)) %>%
  # mutate(pvalue = pchisq(m_dist, df=3, lower.tail=FALSE)) #pval<0.001 outlier

hindi_mdist %>%
  arrange(desc(m_dist))
```

```{r}
# CENTERED
fviz_pca_ind(prcomp(langexp_centered), title = "PCA - Language Experience Data",
             habillage = hindi_dist$outlier,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")

# SCALED
# Plot dataset with PCA to reduce dimensions to 2
fviz_pca_ind(prcomp(langexp_scaled), title = "PCA - Language Experience Data",
             habillage = hindi_dist$outlier,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")
```

#### Define Similarity
* Correlation vs. Distance? 
* If distance, which type of distance?

```{r}
# Try several to see what is the best. Basic is Euclidean

## Distance (both pattern and magnitutde)
get_dist(langexp_scaled, method="euclidean")
get_dist(langexp_scaled, method="manhattan")

## Correlation (pattern only)
get_dist(langexp_scaled, method="pearson")
get_dist(langexp_scaled, method="spearman")
```

### Stage 3: Assumptions
#### Assess Sample Representativeness
<!-- What kind of sample was this? Was it random selection? Does it oversample from certain parts of South Asia/USA?-->

#### Assess Multicollinearity
Addressed during Clustering Variable selection ('Check Multicollinearity')

#### Assess Clustering Tendency
```{r}
# CENTERED
# Create and plot Random dataset to compare to actual
random_df <- apply(langexp_centered, 2, function(x){runif(length(x), min(x), (max(x)))})
random_df <- as.data.frame(random_df)
random_centered <- as.data.frame(lapply(random_df, scale, scale=FALSE))
# random_centered

# Plot random dataset with PCA to reduce dimensions to 2
fviz_pca_ind(prcomp(random_centered), title = "PCA - Language Exp Data (Centered)",
             habillage = hindi_groups$native_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")

# SCALED
# Create and plot Random dataset to compare to actual
random_df <- apply(langexp_scores, 2, function(x){runif(length(x), min(x), (max(x)))})
random_df <- as.data.frame(random_df)
random_scaled <- as.data.frame(lapply(random_df, scale))
# random_scaled

# Plot random dataset with PCA to reduce dimensions to 2
fviz_pca_ind(prcomp(random_scaled), title = "PCA - Language Exp Data (Scaled)",
             habillage = hindi_groups$native_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")
```


```{r}
# CENTERED
#### Visual Inspection
# Plot dataset with PCA to reduce dimensions to 2
fviz_pca_ind(prcomp(langexp_centered), title = "PCA - Language Experience Data (Centered)",
             habillage = hindi_groups$native_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")

fviz_pca_ind(prcomp(langexp_centered), title = "PCA - Language Experience Data (Centered)",
             habillage = hindi_groups$residence_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")

# SCALED
#### Visual Inspection
# Plot dataset with PCA to reduce dimensions to 2
fviz_pca_ind(prcomp(langexp_scaled), title = "PCA - Language Experience Data (Scaled)",
             habillage = hindi_groups$native_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")

fviz_pca_ind(prcomp(langexp_scaled), title = "PCA - Language Experience Data (Scaled)",
             habillage = hindi_groups$residence_group,  palette = "jco",
             geom = "point", ggtheme = theme_classic(),
             legend = "bottom")
```

```{r}
# Check Hopkins statistics (above 0.5 is threshold)

# CENTERED
res <- get_clust_tendency(langexp_centered, n = nrow(langexp_scaled)-1, graph = FALSE)
res$hopkins_stat

# SCALED
res <- get_clust_tendency(langexp_scaled, n = nrow(langexp_scaled)-1, graph = FALSE)
res$hopkins_stat
```

# .
## Part 1: Partitioning Cluster Analysis 
### Stage 4: Employing Hierarchical Clustering

#### 1) Select Clustering Algorithm
Selected Options:
* Average (classes of any shape & size; typical default; less affected by outliers, somewhere in between single/complete methods)
* Ward's (types in circular shape, i.e. compact, spherical clusters; similar sized tendency)
* Complete (generally round similar clusters; affected by outliers)

Not:
* Centroid (political platforms; typical default; less affected by outliers)
* Single (nearest neighours, often long links)


#### 2) Initial Cluster Results
##### Run Clustering
```{r}
# Euclidean Distances

# AVERAGE LINKAGE
clust_ave <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "average")
dend_ave <- clust_ave %>% as.dendrogram()

# WARDS
clust_ward <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "ward.D2")
dend_ward <- clust_ward %>% as.dendrogram()

# COMPLETE LINKAGE
clust_comp <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "complete")
dend_comp <- clust_comp %>% as.dendrogram()
```

```{r}
# # Mahalanobis distance
# mahal_dist <- biotools::D2.dist(langexp_scaled, cov(langexp_scaled))
# 
# # AVERAGE LINKAGE
# clust_ave <-
#   mahal_dist %>% 
#   hclust(method = "average")
# dend_ave <- clust_ave %>% as.dendrogram()
```

##### Assess Number of Clusters
```{r}
# Elbow method
fviz_nbclust(langexp_scaled, hcut, method = "wss", k.max = 10) +
  labs(subtitle = "Elbow method")

# Silhouette method
fviz_nbclust(langexp_scaled, hcut, method = "silhouette", k.max = 10) +
  labs(subtitle = "Silhouette method")

# Gap statistic
# nboot = 50 to keep the function speedy. 
# recommended value: nboot= 500 for your analysis.
# Use verbose = FALSE to hide computing progression.
#calculate gap statistic for each number of clusters (up to 10 clusters)
gap_stat <- clusGap(langexp_scaled, FUN = hcut, nstart = 25, K.max = 10, B = 50)

#produce plot of clusters vs. gap statistic
fviz_gap_stat(gap_stat)
```

```{r}
# Calculate 30 different indices of cluster size and pick consensus

# Average (classes of any shape)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="average", index="all")
# NbClust(langexp_scaled, diss=mahal_dist, distance=NULL, min.nc=2, max.nc=10, method="average", index="all")
```

```{r}
# Ward's (types in circular shape)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="ward.D2", index="all")
# NbClust(langexp_scaled, distance="manhattan", min.nc=2, max.nc=10, method="ward.D2", index="all")
```

```{r}
# Complete (circles)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="complete", index="all")
```

```{r}
#cut the dendrogram into 3 clusters
clusters_2 <- cutree(clust_ave, k=2)
clusters_3 <- cutree(clust_ave, k=3)
clusters_4 <- cutree(clust_ave, k=4)

#find number of observations in each cluster
table(clusters_2)
table(clusters_3)
table(clusters_4)
```

##### Plot Dendrogram
```{r}
# 4-cluster
# Make the dendrogram
# png(filename = "output/langexp/langexp_clust3_dendextend_v4.png", res = 300, width = 12, height = 5, units = 'in')

par(mar=c(4,4,0,0))
dend_ave %>%
  set("leaves_pch", 19)  %>% 
  set("nodes_cex", 0.7) %>% 
  plot(cex.axis=1.5) #horiz=TRUE
rect.dendrogram(dend_ave, k=4, which=1, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[2],0.1))
rect.dendrogram(dend_ave, k=4, which=2, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[4],0.1))
rect.dendrogram(dend_ave, k=4, which=3, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[3],0.1))
rect.dendrogram(dend_ave, k=4, which=4, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[1],0.1))

# Add the colored bar
colored_bars(colors = cbind(residence_colors, native_colors), 
             dend = dend_ave, 
             rowLabels = c("residence", "native"), 
             y_scale = 2,
             cex.rowLabels = 1.2) #, horiz=TRUE
# Add legend
legend(x = 55, y = 8, #"topright", 
       title = "Native Identification",
       legend = native_colors_list[,1], 
       fill = native_colors_list[,2], 
       border = native_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)
legend(x = 55, y = 4, #"topright", 
       title = "Residence History",
       legend = residence_colors_list[,1], 
       fill = residence_colors_list[,2], 
       border = residence_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)

# dev.off()
```

#### 3) Respecified Cluster Results
##### Remove Outlier(s)
```{r}
# Remove outlier(s) & recreate dataframes
hindi_groups <- hindi_groups %>% filter(participant!="r_yw6mqjwaz5dijox")
hindi_langexp <- hindi_langexp %>% filter(participant!="r_yw6mqjwaz5dijox")
langexp_scores <- hindi_langexp %>% select(-participant)

native_colors <- case_when(
  hindi_groups$native_group=="both" ~ brewer.pal(4, "YlGnBu")[4], 
  hindi_groups$native_group=="Eng" ~ brewer.pal(4, "YlGnBu")[3],
  hindi_groups$native_group=="HU" ~ brewer.pal(4, "YlGnBu")[2], 
  hindi_groups$native_group=="neither" ~ brewer.pal(4, "YlGnBu")[1], 
  TRUE ~ "white") #cornflowerblue, chocolate2

residence_colors <- case_when(
  hindi_groups$residence_group=="SouthAs" ~ brewer.pal(4, "YlOrBr")[4], 
  hindi_groups$residence_group=="SAtoNA" ~ brewer.pal(4, "YlOrBr")[3],
  hindi_groups$residence_group=="NorthAm" ~ brewer.pal(4, "YlOrBr")[2], 
  TRUE ~ brewer.pal(4, "YlOrBr")[1]) 

# Mean-centered only (CENTERED)
langexp_centered <- as.data.frame(lapply(langexp_scores, scale, center=TRUE, scale=FALSE))
langexp_centered

# Z-scored (SCALED)
langexp_scaled <- as.data.frame(lapply(langexp_scores, scale))
langexp_scaled
```

##### Run Clustering
```{r}
# Euclidean Distances

# AVERAGE LINKAGE
clust_ave <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "average")
dend_ave <- clust_ave %>% as.dendrogram()

# WARDS
clust_ward <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "ward.D2")
dend_ward <- clust_ward %>% as.dendrogram()

# COMPLETE LINKAGE
clust_comp <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "complete")
dend_comp <- clust_comp %>% as.dendrogram()
```


##### Assess Number of Clusters
```{r}
# Elbow method
fviz_nbclust(langexp_scaled, hcut, method = "wss", k.max = 10) +
  labs(subtitle = "Elbow method")

# Silhouette method
fviz_nbclust(langexp_scaled, hcut, method = "silhouette", k.max = 10) +
  labs(subtitle = "Silhouette method")

# Gap statistic
# nboot = 50 to keep the function speedy. 
# recommended value: nboot= 500 for your analysis.
# Use verbose = FALSE to hide computing progression.
#calculate gap statistic for each number of clusters (up to 10 clusters)
gap_stat <- clusGap(langexp_scaled, FUN = hcut, nstart = 25, K.max = 10, B = 50)

#produce plot of clusters vs. gap statistic
fviz_gap_stat(gap_stat)
```

```{r}
# Calculate 30 different indices of cluster size and pick consensus

# Average (classes of any shape)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="average", index="all")
# NbClust(langexp_scaled, diss=mahal_dist, distance=NULL, min.nc=2, max.nc=10, method="average", index="all")
```

```{r}
# Ward's (types in circular shape)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="ward.D2", index="all")
# NbClust(langexp_scaled, distance="manhattan", min.nc=2, max.nc=10, method="ward.D2", index="all")
```

```{r}
# Complete (circles)
NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="complete", index="all")
```

```{r}
#cut the dendrogram into 3 clusters
clusters_2 <- cutree(clust_ave, k=2)
clusters_3 <- cutree(clust_ave, k=3)
clusters_4 <- cutree(clust_ave, k=4)

#find number of observations in each cluster
table(clusters_2)
table(clusters_3)
table(clusters_4)
```

##### Plot Dendrogram
```{r}
# 3-cluster
# Make the dendrogram
# png(filename = "output/langexp/langexp_clust3_dendextend_v3.png", res = 300, width = 12, height = 5, units = 'in')

par(mar=c(4,4,0,0))
dend_ave %>%
  set("leaves_pch", 19)  %>% 
  # set("labels_col") %>% #value = brewer.pal(9, "Greys")[5:9], k=3
  # set("branches_k_color") %>% # , value = brewer.pal(9, "Greys")[5:9], k=3
  set("nodes_cex", 0.7) %>% 
  plot(cex.axis=1.5) #horiz=TRUE
rect.dendrogram(dend_ave, k=3, which=1, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[2],0.1))
rect.dendrogram(dend_ave, k=3, which=2, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[4],0.1))

# Add the colored bar
colored_bars(colors = cbind(residence_colors, native_colors), 
             dend = dend_ave, 
             rowLabels = c("residence", "native"), 
             y_scale = 1,
             cex.rowLabels = 1.2) #, horiz=TRUE
# Add legend
legend(x = 55, y = 5, #"topright", 
       title = "Native Identification",
       legend = native_colors_list[,1], 
       fill = native_colors_list[,2], 
       border = native_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)
legend(x = 55, y = 2.5, #"topright", 
       title = "Residence History",
       legend = residence_colors_list[,1], 
       fill = residence_colors_list[,2], 
       border = residence_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)

# dev.off()
```

```{r}
# 2-cluster
# Make the dendrogram
# png(filename = "output/langexp/langexp_clust3_dendextend_v3.png", res = 300, width = 12, height = 5, units = 'in')

par(mar=c(4,4,0,0))
dend_ave %>%
  set("leaves_pch", 19)  %>% 
  # set("labels_col") %>% #value = brewer.pal(9, "Greys")[5:9], k=3
  # set("branches_k_color") %>% # , value = brewer.pal(9, "Greys")[5:9], k=3
  set("nodes_cex", 0.7) %>% 
  plot(cex.axis=1.5) #horiz=TRUE
rect.dendrogram(dend_ave, k=2, which=1, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[2],0.1))
rect.dendrogram(dend_ave, k=2, which=2, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[4],0.1))

# Add the colored bar
colored_bars(colors = cbind(residence_colors, native_colors), 
             dend = dend_ave, 
             rowLabels = c("residence", "native"), 
             y_scale = 1,
             cex.rowLabels = 1.2) #, horiz=TRUE
# Add legend
legend(x = 55, y = 5, #"topright", 
       title = "Native Identification",
       legend = native_colors_list[,1], 
       fill = native_colors_list[,2], 
       border = native_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)
legend(x = 55, y = 2.5, #"topright", 
       title = "Residence History",
       legend = residence_colors_list[,1], 
       fill = residence_colors_list[,2], 
       border = residence_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)

# dev.off()
```

```{r}
# 4-cluster

native_colors_list <- c("both", "Eng", "HU", "neither") %>% 
  cbind(c(brewer.pal(4, "YlGnBu")[4],
          brewer.pal(4, "YlGnBu")[3],
          brewer.pal(4, "YlGnBu")[2],
          brewer.pal(4, "YlGnBu")[1]))

# Make the dendrogram
png(filename = "output/langexp/langexp_clust4_dendextend.png", res = 300, width = 12, height = 5, units = 'in')

par(mar=c(6,4,2,0))
dend_ave %>%
  set("leaves_pch", 19)  %>% 
  # set("labels_col") %>% #value = brewer.pal(9, "Greys")[5:9], k=3
  # set("branches_k_color") %>% # , value = brewer.pal(9, "Greys")[5:9], k=3
  set("nodes_cex", 0.7) %>% 
  plot(cex.axis=1.5) #horiz=TRUE
rect.dendrogram(dend_ave, k=4, which=1, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[2],0.1))
rect.dendrogram(dend_ave, k=4, which=2, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[4],0.1))
rect.dendrogram(dend_ave, k=4, which=3, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[3],0.1))
rect.dendrogram(dend_ave, k=4, which=4, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[1],0.1))


# Add the colored bar
colored_bars(colors = cbind(residence_colors, native_colors), 
             dend = dend_ave, 
             rowLabels = c("residence", "native"), 
             y_scale = 1,
             cex.rowLabels = 1.2) #, horiz=TRUE
# Add legend
legend("topright",  #x = 55, y = 5, 
       inset=c(0.2,-0.1), #0.14,-0.1
       title = "Native Identity",
       legend = native_colors_list[,1], 
       fill = native_colors_list[,2], 
       border = native_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2, 
       xpd = TRUE)
legend("topright", #x = 55, y = 2.5,
      inset=c(0.02,-0.1), #-0.02, -0.1
      title = "Residence History",
      legend = residence_colors_list[,1],
      fill = residence_colors_list[,2],
      border = residence_colors_list[,2],
      xjust = 0,
      bty = "n",
      cex = 1.2,
      xpd = TRUE)

dev.off()
```

##### Select Cluster Solutions
```{r}
# append cluster labels to original data
langexp_final_data <- 
  cbind(hindi_groups, clusters_2 = clusters_2) %>%
  cbind(clusters_3 = clusters_3) %>%
  cbind(clusters_4 = clusters_4) %>%
  cbind(langexp_scores) %>%
  cbind(langexp_scaled %>% rename_with(., ~ paste(.x, "z", sep="."))) %>%
  mutate(across(starts_with("clusters"), as.factor))
langexp_final_data
# View(langexp_final_data)
```

```{r}
# prepare exportable data for follow-up analysis
# langexp_final_data %>%
#     mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
#                                   clusters_4 == 2 ~ "A",
#                                   clusters_4 == 3 ~ "D",
#                                   clusters_4 == 4 ~ "B"))  %>% 
#   rename(Cluster=clusters_4) %>%
#   select(-clusters_2, -clusters_3) %>%
#   save(file="data/processed/langexp_final_data.RData")
```

### Stage 5: Profiling Clustering Variable

##### Examine Cluster Plots
```{r}
# Plot clusters
fviz_cluster(list(data = langexp_scaled, cluster = clusters_3),
             ellipse.type = "norm", geom = "point", stand = FALSE,
             palette = "jco") + gg_theme() + 
  labs(fill = "Cluster", color = "Cluster", shape = "Cluster")

fviz_cluster(list(data = langexp_scaled, cluster = clusters_2),
             ellipse.type = "norm", geom = "point", stand = FALSE,
             palette = "jco") + gg_theme() + 
  labs(fill = "Cluster", color = "Cluster", shape = "Cluster")

fviz_cluster(list(data = langexp_scaled, cluster = clusters_4),
             ellipse.type = "norm", geom = "point", stand = FALSE,
             palette = "jco") + gg_theme() + 
  labs(fill = "Cluster", color = "Cluster", shape = "Cluster")
# ggsave("./output/langexp/langexp_clust4_cluster.png")

```

#### Examine Cluster Distinctiveness
```{r}
# Examine variable distinctiveness of each cluster solution
summary(lm(hear_child ~ clusters_3, data=langexp_final_data))
summary(lm(speak_child ~ clusters_3, data=langexp_final_data))
summary(lm(hear_now ~ clusters_3, data=langexp_final_data))
summary(lm(speak_now ~ clusters_3, data=langexp_final_data))
summary(lm(read_now ~ clusters_3, data=langexp_final_data))
summary(lm(write_now ~ clusters_3, data=langexp_final_data))
summary(lm(comfort_understand ~ clusters_3, data=langexp_final_data))
summary(lm(comfort_speak ~ clusters_3, data=langexp_final_data))
summary(lm(comfort_readwrite ~ clusters_3, data=langexp_final_data))
```

```{r}
summary(lm(hear_child ~ clusters_2, data=langexp_final_data))
summary(lm(speak_child ~ clusters_2, data=langexp_final_data))
summary(lm(hear_now ~ clusters_2, data=langexp_final_data))
summary(lm(speak_now ~ clusters_2, data=langexp_final_data))
summary(lm(read_now ~ clusters_2, data=langexp_final_data))
summary(lm(write_now ~ clusters_2, data=langexp_final_data))
summary(lm(comfort_understand ~ clusters_2, data=langexp_final_data))
summary(lm(comfort_speak ~ clusters_2, data=langexp_final_data))
summary(lm(comfort_readwrite ~ clusters_2, data=langexp_final_data))
```

```{r}
summary(lm(hear_child ~ clusters_4, data=langexp_final_data))
summary(lm(speak_child ~ clusters_4, data=langexp_final_data))
summary(lm(hear_now ~ clusters_4, data=langexp_final_data))
summary(lm(speak_now ~ clusters_4, data=langexp_final_data))
summary(lm(read_now ~ clusters_4, data=langexp_final_data))
summary(lm(write_now ~ clusters_4, data=langexp_final_data))
summary(lm(comfort_understand ~ clusters_4, data=langexp_final_data))
summary(lm(comfort_speak ~ clusters_4, data=langexp_final_data))
summary(lm(comfort_readwrite ~ clusters_4, data=langexp_final_data))
```

#### Cluster Mean Tables
```{r}
cluster_means_3 <- langexp_final_data %>% group_by(clusters_3) %>%
  mutate(clusters_3 = case_when(clusters_3 == 1 ~ "C",
                              clusters_3 == 2 ~ "A",
                              clusters_3 == 3 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child:comfort_readwrite, mean)) %>% 
  rename(Cluster = clusters_3)
cluster_means_3

cluster_zmeans_3 <- langexp_final_data %>% group_by(clusters_3) %>%
  mutate(clusters_3 = case_when(clusters_3 == 1 ~ "C",
                              clusters_3 == 2 ~ "A",
                              clusters_3 == 3 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child.z:comfort_readwrite.z, mean)) %>% 
  rename(Cluster = clusters_3)
cluster_zmeans_3

```

```{r}
cluster_means_2 <- langexp_final_data %>% group_by(clusters_2) %>%
  mutate(clusters_2 = case_when(clusters_2 == 2 ~ "A",
                              clusters_2 == 1 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child:comfort_readwrite, mean)) %>% 
  rename(Cluster = clusters_2)
cluster_means_2

cluster_zmeans_2 <- langexp_final_data %>% group_by(clusters_2) %>%
  mutate(clusters_2 = case_when(clusters_2 == 2 ~ "A",
                              clusters_2 == 1 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child.z:comfort_readwrite.z, mean)) %>% 
  rename(Cluster = clusters_2)
cluster_zmeans_2
```

```{r}
cluster_means_4 <- langexp_final_data %>% group_by(clusters_4) %>%
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child:comfort_readwrite, mean)) %>% 
  rename(Cluster = clusters_4)
cluster_means_4

print(xtable::xtable(cluster_means_4, type = "latex"), file = "output/langexp/clustermeans.tex")

cluster_zmeans_4 <- langexp_final_data %>% group_by(clusters_4) %>%
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child.z:comfort_readwrite.z, mean)) %>% 
  rename(Cluster = clusters_4)
cluster_zmeans_4

# print(xtable::xtable(cluster_zmeans_4, type = "latex"), file = "output/langexp/clusterzmeans.tex")

```

#### Cluster Mean Plots
```{r}
# Cluster mean Bar plots faceted by Cluster
cluster3.plt <- 
  cluster_means_3 %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, fill=variable)) +
  geom_col(position="dodge", width=0.8, alpha=0.8) +
  facet_wrap(~Cluster) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))
cluster3.plt

# Cluster individual bar plots faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(clusters_3 = case_when(clusters_3 == 1 ~ "C",
                              clusters_3 == 2 ~ "A",
                              clusters_3 == 3 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, fill=variable, color=variable, alpha=participant)) +
  geom_col(position="dodge", width=0.8) +
  facet_wrap(~clusters_3, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))


# Cluster individual line graphs faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(clusters_3 = case_when(clusters_3 == 1 ~ "C",
                              clusters_3 == 2 ~ "A",
                              clusters_3 == 3 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, color=clusters_3, group=participant)) +
  geom_point(alpha=0.5) +
  geom_line(alpha=0.5) +
  facet_wrap(~clusters_3, ncol=3) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# Cluster mean line graph comparing across clusters
cluster_means_3 %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point() +
  geom_line() +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# ggsave("output/langexp/langexp_clust3_means.png", width=12, height=7)

# Cluster Z-mean (relative) line graph comparing across clusters
cluster_zmeans_3 %>%
  pivot_longer(hear_child.z:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child.z", "speak_child.z", "hear_now.z", "speak_now.z", "read_now.z", "write_now.z", "comfort_understand.z", "comfort_speak.z", "comfort_readwrite.z"))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point() +
  geom_line() +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# ggsave("output/langexp/langexp_clust3_zmeans.png", width=12, height=7)
```


```{r, error=FALSE}
# Cluster mean Bar plots faceted by Cluster
cluster4.plt <- 
  cluster_means_4 %>% 
  
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, fill=variable)) +
  geom_col(position="dodge", width=0.8, alpha=0.8) +
  facet_wrap(~Cluster, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))
cluster4.plt

# Cluster individual bar plots faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, fill=variable, color=variable, alpha=participant)) +
  geom_col(position="dodge", width=0.8) +
  facet_wrap(~clusters_4, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))


# Cluster individual line graphs faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, color=clusters_4, group=participant)) +
  geom_point(alpha=0.5) +
  geom_line(alpha=0.5) +
  facet_wrap(~clusters_4, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))
```


```{r, error=FALSE}
# Cluster mean line graph comparing across clusters
cluster_means_4 %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  # mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  # # For plot readability
  # mutate(variable = gsub("_now", "_current", variable, fixed=TRUE)) %>%
  # mutate(variable = gsub("_understand", "_underst.", variable, fixed=TRUE)) %>%
  mutate(variable = case_when(variable == "hear_child" ~ "child_hear",
                              variable == "speak_child" ~ "child_speak",
                              variable == "hear_now" ~ "current_hear",
                              variable == "speak_now" ~ "current_speak",
                              variable == "read_now" ~ "current_read",
                              variable == "write_now" ~ "current_write",
                              variable == "comfort_understand" ~ "comfort_underst.",
                              variable == "comfort_speak" ~ "comfort_speak",
                              variable == "comfort_readwrite" ~ "comfort_readwr.")) %>%
  mutate(variable = factor(variable, levels = c("child_hear", "child_speak", "current_hear", "current_speak", "current_read", "current_write", "comfort_underst.", "comfort_speak", "comfort_readwr."))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point(size=5) +
  geom_line(lwd=3) +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 25, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=30),
        axis.text=element_text(size=25),
        strip.text = element_text(size=30)) +
  theme(legend.title = element_text(size=30, face="bold"),
        legend.text=element_text(size=25))

ggsave("output/langexp/langexp_clust4_means.png", width=12, height=7)


# Cluster Z-mean (relative) line graph comparing across clusters
cluster_zmeans_4 %>%
  pivot_longer(hear_child.z:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child.z", "speak_child.z", "hear_now.z", "speak_now.z", "read_now.z", "write_now.z", "comfort_understand.z", "comfort_speak.z", "comfort_readwrite.z"))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point() +
  geom_line() +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# ggsave("output/langexp/langexp_clust4_zmeans.png", width=12, height=7)

```

### Stage 6: Validation and Profiling of Clusters

#### Validate Cluster Stability (Internal)
```{r}
# Silhouette Plot
# A large value (close to 1) represents good clustering; Close to -1 means bad (wrong cluster)
sil <- silhouette(clusters_4, dist(langexp_scaled))
fviz_silhouette(sil, palette="jco") + theme_bw()

sil <- silhouette(cluster3, dist(langexp_scaled))
fviz_silhouette(sil, palette="jco") + theme_bw()
```

```{r}
# Dunn Index
# A large Dunn index reprsents good clustering (min.separation/max.diamenter)
km.stats <- cluster.stats(dist(langexp_scaled), clusters_4)
km.stats$dunn
```

#### Assessing Criterion Validity
```{r}
# 4-cluster v. Native

# How well do clusters match group structure?
native_groups <- as.numeric(as.factor(hindi_groups$native_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), native_groups, clusters_4)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(native_groups,clusters_4)
```

```{r}
# 4-cluster v. residence

# How well do clusters match group structure?
residence_groups <- as.numeric(as.factor(hindi_groups$residence_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), residence_groups,clusters_4)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(residence_groups,clusters_4)
```

#### Profiling Final Cluster Solution


##### Count Tables
```{r}
# 4-cluster table
cluster_counts <- 
  langexp_final_data %>% mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>% 
  count(clusters_4) %>%
  merge(langexp_final_data %>% 
          mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%
          group_by(clusters_4) %>%
          count(native_group) %>% pivot_wider(names_from = native_group, values_from=n) 
        ) %>%
  merge(langexp_final_data %>% mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>%
          group_by(clusters_4) %>% 
          count(residence_group) %>% pivot_wider(names_from = residence_group, values_from=n)
        ) %>%
  mutate(across(where(is.numeric), ~ coalesce(.x, 0))) %>%
  rename(Cluster = clusters_4) %>%
  
  as_tibble() %>%
  gt(rowname_col = "Cluster") %>%
  tab_header(
    title = "Category Counts by Cluster",
    subtitle = "4-cluster solution via hierarchical clustering"
  ) %>%
  fmt_integer(
    columns = everything()
  ) %>%
  tab_stubhead(label = "Cluster") %>%
  tab_spanner(
    label = "Native Identification",
    columns = c(both, Eng, HU, neither)
  ) %>%
  tab_spanner(
    label = "Residential History",
    columns = c(NorthAm, SAtoNA, SouthAs, uncategorized)
  ) %>%
  grand_summary_rows(
    columns = everything(),
    fns = list(
      Sum = ~sum(., na.rm=TRUE)),
    missing_text = "NA",
    formatter = fmt_integer
  ) %>%
  cols_align(align = c("center"),
             columns = everything()
             # columns = n
  ) %>%
  tab_style(style = cell_borders(color = "lightgrey", sides = c("left"), weight = px(2)),
            locations = list(
              cells_column_spanners(),
              cells_column_labels(columns = NorthAm),
              cells_body(columns = NorthAm),
              cells_grand_summary(columns = NorthAm)
            )
            ) %>%
  tab_style(style = list(
    cell_borders(color = "lightgrey", sides = c("left", "right"), weight = px(2)),
    cell_text(style = "italic")
    ), 
            locations = list(
              cells_column_labels(columns = n),
              cells_body(columns = n),
              cells_grand_summary(columns = n)
              )
            ) %>%
  tab_style(style = cell_text(weight="bold"), 
            locations = list(
              cells_title(groups= "title"),
              cells_column_spanners(),
              cells_stubhead(),
              cells_grand_summary(columns = everything(), rows = TRUE)
              )
            )
cluster_counts

gtsave(cluster_counts, "output/langexp/langexp_clust4_counts.html")
webshot2::webshot("output/langexp/langexp_clust4_counts.html", "output/langexp/langexp_clust4_counts.png", vwidth = 625, zoom = 2.5)
gtsave(cluster_counts, "output/langexp/langexp_clust4_counts.tex")
```

##### Cross Tabulation
```{r}
# Native counts x 4-cluster solution
native_counts <- langexp_final_data %>% 
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>% 
  group_by(clusters_4) %>% count(native_group) %>% 
  pivot_wider( names_from=c(native_group), values_from=n) %>%
    mutate(across(where(is.numeric), ~ coalesce(.x, 0))) %>%
  column_to_rownames(var="clusters_4")
native_counts

# Residence counts x 4-cluster solution
residence_counts <- langexp_final_data %>% 
  mutate(clusters_4 = case_when(clusters_4 == 1 ~ "C",
                              clusters_4 == 2 ~ "A",
                              clusters_4 == 3 ~ "D",
                              clusters_4 == 4 ~ "B"))  %>% 
  group_by(clusters_4) %>% count(residence_group) %>% 
  pivot_wider(names_from=c(residence_group), values_from=n) %>%
   mutate(across(where(is.numeric), ~ coalesce(.x, 0))) %>%
  column_to_rownames(var="clusters_4")
residence_counts
```

```{r}
chisq <- chisq.test(native_counts)
chisq

chisq$observed
round(chisq$expected,2)

# Residuals
round(chisq$residuals, 3)

# Visualize residuals
corrplot(chisq$residuals, is.cor = FALSE)

# Contibution in percentage (%)
contrib <- 100*chisq$residuals^2/chisq$statistic
round(contrib, 3)

# Visualize the contribution
corrplot(contrib, is.cor = FALSE,method="circle", col=colorRampPalette(c("lightblue1","skyblue2","royalblue4"))(100),cl.lim=c(0,25))
corrplot(contrib, is.cor = FALSE,method="number", col=colorRampPalette(c("lightblue1","skyblue2","royalblue4"))(100),cl.lim=c(0,25))

```


```{r}
chisq <- chisq.test(residence_counts)
chisq

chisq$observed
round(chisq$expected,2)

# Residuals
round(chisq$residuals, 3)

# Visualize residuals
corrplot(chisq$residuals, is.cor = FALSE)

# Contibution in percentage (%)
contrib <- 100*chisq$residuals^2/chisq$statistic
round(contrib, 3)

# Visualize the contribution
corrplot(contrib, is.cor = FALSE,method="circle", col=colorRampPalette(c("lightblue1","skyblue2","royalblue4"))(100),cl.lim=c(0,25))
corrplot(contrib, is.cor = FALSE,method="number", col=colorRampPalette(c("lightblue1","skyblue2","royalblue4"))(100),cl.lim=c(0,25))
```

##### Cluster Profile Descriptions
A = Mostly North American, English native speakers (both to a lesser extent)
B = South Asian, Hindi-Urdu native speakers
C = SA to NA (and uncategorized) migrants, who have a range of nativeness iden.
D = Mostly North American, mostly English and neither nativeness identification


# ...
# For Reference

```{r}
# gtsave(cluster_counts3, "output/langexp_clust3_counts.png", delay=5) 
## no bold (known bug but unfixed as of Aug 2021; workaround: https://github.com/rstudio/gt/issues/621)
```


#### Test Runs
```{r}
#perform hierarchical clustering using Ward's minimum variance
set.seed(168)
clust <- agnes(langexp_scaled, method = "average")
clust

#produce dendrogram
# png(filename ="output/langexp_dendrogram.png")
pltree(clust, cex = 0.6, hang = -1, main = "Dendrogram")
```


```{r}
#compute distance matrix
d <- dist(langexp_scaled, method = "euclidean")

#perform hierarchical clustering using Ward's method
set.seed(168)
hclust_ward <- hclust(d, method = "ward.D2")
hclust_avg <- hclust(d, method = "average" )
hclust_cmp <- hclust(d, method = "complete")
hclust_sgl <- hclust(d, method = "single" )

```

```{r}
plot(hclust_ward)
plot(hclust_avg)
plot(hclust_cmp)
plot(hclust_sgl)
```


###### Plots via ggDendro
```{r}
library(ggdendro)

# Quick wrapper plot
ggdendrogram(dend, rotate=T) +
  labs(title = "Language Experience Clustering")

ddata <- dendro_data(dend, type="rectangle")

p <- ggplot(segment(ddata)) +
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
  coord_flip() +
  # scale_y_reverse(expand = c(0.2, 0)) +
  theme_dendro()
p

label(ddata)
```

```{r}
RColorBrewer::brewer.pal(4, "Blues")[2:5]
RColorBrewer::brewer.pal(9, "YlGnBu")[9]
RColorBrewer::brewer.pal(8, "Greens")

RColorBrewer::brewer.pal(9, "YlOrBr")[9]
```



##### Rest of Clustering

```{r}
# #perform hierarchical clustering using Ward's minimum variance
# set.seed(168)
# clust <- agnes(langexp_scaled, method = "ward")
# clust
# 
# #produce dendrogram
# # png(filename ="output/langexp_dendrogram.png")
# pltree(clust, cex = 0.6, hang = -1, main = "Dendrogram") 
```

```{r}
#compute distance matrix
d <- dist(langexp_scaled, method = "euclidean")

#perform hierarchical clustering using Ward's method
set.seed(168)
final_clust <- hclust(d, method = "ward.D2")
```

```{r}
#cut the dendrogram into 8 clusters
cluster8 <- cutree(final_clust, k=8)

#find number of observations in each cluster
table(cluster8)

#cut the dendrogram into 3 clusters
cluster3 <- cutree(final_clust, k=3)

#find number of observations in each cluster
table(cluster3)
```

```{r}
png(filename = "output/langexp/langexp_clust3_dendrogram.png", res = 300, width = 12, height = 7, units = 'in')
plot(final_clust)
rect.hclust(final_clust , k = 3, border = 2:6)
# abline(h = 12.25, col = 'red')
```

```{r}
png(filename = "output/langexp/langexp_clust8_dendrogram.png", res = 300, width = 12, height = 7, units = 'in')
plot(final_clust)
rect.hclust(final_clust , k = 8, border = 2:6)
# abline(h = 5, col = 'red')
```

## Initial Runs (before Hair et al.)
### Hierarchical Clustering w/ All data

#### Prep
```{r}
# Create a vector of colors
native_colors_list <- c("both", "Eng", "HU", "neither              ") %>% 
  cbind(c(brewer.pal(4, "YlGnBu")[4],
          brewer.pal(4, "YlGnBu")[3],
          brewer.pal(4, "YlGnBu")[2],
          brewer.pal(4, "YlGnBu")[1]))

residence_colors_list <- c("SouthAs", "SAtoNA", "NorthAm", "uncategorized") %>% 
  cbind(c(brewer.pal(4, "YlOrBr")[4],
          brewer.pal(4, "YlOrBr")[3],
          brewer.pal(4, "YlOrBr")[2],
          brewer.pal(4, "YlOrBr")[1]))

native_colors <- case_when(
  hindi_groups$native_group=="both" ~ brewer.pal(4, "YlGnBu")[4], 
  hindi_groups$native_group=="Eng" ~ brewer.pal(4, "YlGnBu")[3],
  hindi_groups$native_group=="HU" ~ brewer.pal(4, "YlGnBu")[2], 
  hindi_groups$native_group=="neither" ~ brewer.pal(4, "YlGnBu")[1], 
  TRUE ~ "white") #cornflowerblue, chocolate2

residence_colors <- case_when(
  hindi_groups$residence_group=="SouthAs" ~ brewer.pal(4, "YlOrBr")[4], 
  hindi_groups$residence_group=="SAtoNA" ~ brewer.pal(4, "YlOrBr")[3],
  hindi_groups$residence_group=="NorthAm" ~ brewer.pal(4, "YlOrBr")[2], 
  TRUE ~ brewer.pal(4, "YlOrBr")[1]) 
```

```{r}
# Brewer pallette options
## Sequential
RColorBrewer::display.brewer.pal(4, "OrRd") ###
RColorBrewer::display.brewer.pal(4, "YlOrBr") ###
RColorBrewer::display.brewer.pal(4, "YlGnBu") ###


## Qualitative
RColorBrewer::display.brewer.pal(4, "Set2")
RColorBrewer::display.brewer.pal(4, "Paired")
RColorBrewer::display.brewer.pal(4, "Dark2")

## Diverging (light in the middle)
RColorBrewer::display.brewer.pal(4, "BrBG")
# RColorBrewer::display.brewer.pal(4, "RdGy")
RColorBrewer::display.brewer.pal(4, "RdBu")
RColorBrewer::display.brewer.pal(4, "PuOr")
RColorBrewer::display.brewer.pal(4, "PiYG")
RColorBrewer::display.brewer.pal(4, "PRGn")

# RColorBrewer::display.brewer.pal(4, "RdYlGn")
RColorBrewer::display.brewer.pal(4, "RdYlBu")

# RColorBrewer::display.brewer.pal(4, "Spectral")

```


#### Clustering
```{r}
# Run clustering
clust <-
  langexp_scaled %>% 
  dist(method = "euclidean") %>% 
  hclust(method = "ward.D2")
  
dend <- clust %>% as.dendrogram()
```

```{r}
#cut the dendrogram into 3 clusters
clusters <- cutree(clust, k=3)

#find number of observations in each cluster
table(clusters)
```
```{r}
# append cluster labels to original data
langexp_final_data <- 
  #cbind(hindi_groups, cluster8 = cluster8) %>%
  cbind(hindi_groups, cluster3 = cluster3) %>%
  cbind(langexp_scores)

# View(langexp_final_data)
```

##### Dendrogram
```{r}
# 3-cluster
# Make the dendrogram
png(filename = "output/langexp/langexp_clust3_dendextend_v3.png", res = 300, width = 12, height = 5, units = 'in')

par(mar=c(4,4,0,0))
dend %>%
  set("leaves_pch", 19)  %>% 
  # set("labels_col") %>% #value = brewer.pal(9, "Greys")[5:9], k=3
  # set("branches_k_color") %>% # , value = brewer.pal(9, "Greys")[5:9], k=3
  set("nodes_cex", 0.7) %>% 
  plot(cex.axis=1.5) #horiz=TRUE
rect.dendrogram(dend, k=3, which=1, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[2],0.1))
rect.dendrogram(dend, k=3, which=2, lty = 5, lwd = 0, col=get.rgb(brewer.pal(4, "YlOrBr")[4],0.1))

# Add the colored bar
colored_bars(colors = cbind(residence_colors, native_colors), 
             dend = dend, 
             rowLabels = c("residence", "native"), 
             y_scale = 2,
             cex.rowLabels = 1.2) #, horiz=TRUE
# Add legend
legend(x = 55, y = 21, #"topright", 
       title = "Native Identification",
       legend = native_colors_list[,1], 
       fill = native_colors_list[,2], 
       border = native_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)
legend(x = 55, y = 13.5, #"topright", 
       title = "Residence History",
       legend = residence_colors_list[,1], 
       fill = residence_colors_list[,2], 
       border = residence_colors_list[,2], 
       xjust = 0,
       bty = "n",
       cex = 1.2)

dev.off()

?colored_bars
?legend
```

```{r}
colors_list <- c("both", "Eng", "HU", "neither", "SouthAs", "SAtoNA", "NorthAm", "uncategorized") %>% 
  cbind(c(brewer.pal(4, "YlGnBu")[4],
          brewer.pal(4, "YlGnBu")[3],
          brewer.pal(4, "YlGnBu")[2],
          brewer.pal(4, "YlGnBu")[1],
          brewer.pal(4, "YlOrBr")[4],
          brewer.pal(4, "YlOrBr")[3],
          brewer.pal(4, "YlOrBr")[2],
          brewer.pal(4, "YlOrBr")[1]))
        #"white"))
```


```{r}
# 8-cluster
# Make the dendrogram
png(filename = "output/langexp/langexp_clust8_dendextend.png", res = 300, width = 12, height = 7, units = 'in')

# par(mar=c(11,1,1,1))
dend %>%
  set("leaves_pch", 19)  %>% 
  set("labels_col", value = RColorBrewer::brewer.pal(9, "Greys")[4:9], k=8) %>%
  set("branches_k_color", value = RColorBrewer::brewer.pal(9, "Greys")[5:9], k=8) %>%
  set("nodes_cex", 0.7) %>% 
  plot() #horiz=TRUE
rect.dendrogram(dend, k=8, which=2, lty = 5, lwd = 0, col=rgb(0.4, 1, 0, 0.1))
rect.dendrogram(dend, k=8, which=4, lty = 5, lwd = 0, col=rgb(0.1, 0.2, 1, 0.1))
rect.dendrogram(dend, k=8, which=6, lty = 5, lwd = 0, col=rgb(0.1, 0.6, 0.6, 0.1))
rect.dendrogram(dend, k=8, which=7, lty = 5, lwd = 0, col=rgb(0.1, 0.2, 1, 0.1))
# rect.dendrogram(dend, k=8, which=8, lty = 5, lwd = 0, col=rgb(0.1, 0.2, 0.4, 0.1))

# Add the colored bar
colored_bars(colors = cbind(native, residence), dend = dend, rowLabels = c("native", "residence")) #, horiz=TRUE
# Add legend
legend("topright", legend = colors[,1], fill = colors[,2], border = colors[,2], bty = "n")

dev.off()
```


##### Validate (Internal)
```{r}
# Silhouette Plot
# A large value (close to 1) represents good clustering; Close to -1 means bad (wrong cluster)
sil <- silhouette(cluster8, dist(langexp_scaled))
fviz_silhouette(sil, palette="jco") + theme_bw()

sil <- silhouette(cluster3, dist(langexp_scaled))
fviz_silhouette(sil, palette="jco") + theme_bw()
```

```{r}
# Dunn Index
# A large Dunn index reprsents good clustering (min.separation/max.diamenter)
km.stats <- cluster.stats(dist(langexp_scaled), cluster8)
km.stats$dunn

km.stats <- cluster.stats(dist(langexp_scaled), cluster3)
km.stats$dunn
```

##### Validate (External)
```{r}
# 3-cluster v. Native

# How well do clusters match group structure?
native_groups <- as.numeric(as.factor(hindi_groups$native_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), native_groups,cluster3)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(native_groups,cluster3)
```

```{r}
# 8-cluster v. Native

# How well do clusters match group structure?
native_groups <- as.numeric(as.factor(hindi_groups$native_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), native_groups,cluster8)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(native_groups,cluster8)
```

```{r}
# 3-cluster v. residence

# How well do clusters match group structure?
residence_groups <- as.numeric(as.factor(hindi_groups$residence_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), residence_groups,cluster3)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(residence_groups,cluster3)
```

```{r}
# 8-cluster v. Residence

# How well do clusters match group structure?
residence_groups <- as.numeric(as.factor(hindi_groups$residence_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), residence_groups,cluster8)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(residence_groups,cluster8)
```

#### Data Summary
```{r}
# # Check cluster individuals
# langexp_final_data %>% filter(cluster3==1)
# langexp_final_data %>% filter(cluster3==2)
```


##### Count Tables
```{r}
# Count of smaller clusters within larger clusters
langexp_final_data %>% group_by(cluster3) %>% count(cluster8) %>% pivot_wider(names_from = cluster8, values_from=n)
```

```{r}
# 3-cluster table
cluster_counts3 <- 
  langexp_final_data %>% count(cluster3) %>%
  merge(langexp_final_data %>% group_by(cluster3) %>%
          count(native_group) %>% pivot_wider(names_from = native_group, values_from=n) 
        ) %>%
  merge(langexp_final_data %>% group_by(cluster3) %>% 
          count(residence_group) %>% pivot_wider(names_from = residence_group, values_from=n)
        ) %>%
  mutate(across(where(is.numeric), ~ coalesce(.x, 0))) %>%
  rename(Cluster = cluster3) %>%
  
  as_tibble() %>%
  gt(rowname_col = "Cluster") %>%
  tab_header(
    title = "Category Counts by Cluster",
    subtitle = "3-cluster solution via hierarchical clustering"
  ) %>%
  fmt_integer(
    columns = everything()
  ) %>%
  tab_stubhead(label = "Cluster") %>%
  tab_spanner(
    label = "Native Identification",
    columns = c(both, Eng, HU, neither)
  ) %>%
  tab_spanner(
    label = "Residential History",
    columns = c(NorthAm, SAtoNA, SouthAs, uncategorized)
  ) %>%
  grand_summary_rows(
    columns = everything(),
    fns = list(
      Sum = ~sum(., na.rm=TRUE)),
    missing_text = "NA",
    formatter = fmt_integer
  ) %>%
  cols_align(align = c("center"),
             columns = everything()
             # columns = n
  ) %>%
  tab_style(style = cell_borders(color = "lightgrey", sides = c("left"), weight = px(2)),
            locations = list(
              cells_column_spanners(),
              cells_column_labels(columns = NorthAm),
              cells_body(columns = NorthAm),
              cells_grand_summary(columns = NorthAm)
            )
            ) %>%
  tab_style(style = list(
    cell_borders(color = "lightgrey", sides = c("left", "right"), weight = px(2)),
    cell_text(style = "italic")
    ), 
            locations = list(
              cells_column_labels(columns = n),
              cells_body(columns = n),
              cells_grand_summary(columns = n)
              )
            ) %>%
  tab_style(style = cell_text(weight="bold"), 
            locations = list(
              cells_title(groups= "title"),
              cells_column_spanners(),
              cells_stubhead(),
              cells_grand_summary(columns = everything(), rows = TRUE)
              )
            )
cluster_counts3

gtsave(cluster_counts3, "output/langexp/langexp_clust3_counts.html")
webshot2::webshot("output/langexp/langexp_clust3_counts.html", "output/langexp/langexp_clust3_counts.png", vwidth = 625, zoom = 2.5) 
# gtsave(cluster_counts3, "output/latex/langexp_clust3_counts.tex") 
```

```{r}
# small-cluster table
cluster_counts8 <- 
  langexp_final_data %>% count(cluster8) %>%
  merge(langexp_final_data %>% group_by(cluster3, cluster8) %>%
          count(native_group) %>% pivot_wider(names_from = native_group, values_from=n) 
        ) %>%
  merge(langexp_final_data %>% group_by(cluster3, cluster8) %>% 
          count(residence_group) %>% pivot_wider(names_from = residence_group, values_from=n)
        ) %>%
  mutate(across(where(is.numeric), ~ coalesce(.x, 0))) %>%
  rename(Cluster = cluster8) %>%
  mutate(cluster3 = fct_recode(factor(cluster3), "Cluster 1" = "1", "Cluster 2" = "2", "Cluster 3" = "3")) %>%
  
  as_tibble() %>%
  gt(rowname_col = "Cluster",
     groupname_col = "cluster3") %>%
  tab_header(
    title = "Category Counts by Cluster",
    subtitle = "8-cluster solution via hierarchical clustering"
  ) %>%
  fmt_integer(
    columns = everything()
  ) %>%
  tab_stubhead(label = "Cluster") %>%
  tab_spanner(
    label = "Native Identification",
    columns = c(both, Eng, HU, neither)
  ) %>%
  tab_spanner(
    label = "Residential History",
    columns = c(NorthAm, SAtoNA, SouthAs, uncategorized)
  ) %>%
  grand_summary_rows(
    columns = everything(),
    fns = list(
      Sum = ~sum(., na.rm=TRUE)),
    missing_text = "NA",
    formatter = fmt_integer
  ) %>%
  # summary_rows(
  #   groups = TRUE,
  #   columns = everything(),
  #   fns = list(
  #     Sum = ~sum(., na.rm=TRUE)),
  #   missing_text = "NA",
  #   formatter = fmt_integer
  # ) %>%
  cols_align(align = c("center"),
             columns = everything()
             # columns = n
  ) %>%
  tab_style(style = cell_fill(alpha = 0.5),
            locations = cells_row_groups()) %>%
  tab_style(style = cell_borders(color = "lightgrey", sides = c("left"), weight = px(2)),
            locations = list(
              cells_column_spanners(),
              cells_column_labels(columns = NorthAm),
              cells_body(columns = NorthAm),
              # cells_summary(columns = NorthAm),
              cells_grand_summary(columns = NorthAm)
            )
            ) %>%
  tab_style(style = list(
    cell_borders(color = "lightgrey", sides = c("left", "right"), weight = px(2)),
    cell_text(style = "italic")
    ), 
            locations = list(
              cells_column_labels(columns = n),
              cells_body(columns = n),
              # cells_summary(columns = n),
              cells_grand_summary(columns = n)
              )
            ) %>%
  tab_style(style = cell_text(weight="bold"), 
            locations = list(
              cells_title(groups= "title"),
              cells_column_spanners(),
              cells_stubhead(),
              # cells_summary(columns = everything(), rows = TRUE),
              cells_grand_summary(columns = everything(), rows = TRUE)
              )
            )
cluster_counts8

gtsave(cluster_counts8, "output/langexp/langexp_clust8_counts.html")
webshot2::webshot("output/langexp/langexp_clust8_counts.html", "output/langexp/langexp_clust8_counts.png", vwidth = 625, zoom = 2.5) 
```

##### Cluster Plots
```{r}
# Plot clusters
fviz_cluster(list(data = langexp_scaled, cluster = cluster8),
             ellipse.type = "norm", geom = "point", stand = FALSE,
             palette = "jco") + gg_theme() + 
  labs(fill = "Cluster", color = "Cluster", shape = "Cluster")
ggsave("./output/langexp/langexp_clust8_cluster.png")

# Plot clusters
fviz_cluster(list(data = langexp_scaled, cluster = cluster3),
             ellipse.type = "norm", geom = "point", stand = FALSE,
             palette = "jco") + gg_theme() +
  labs(fill = "Cluster", color = "Cluster", shape = "Cluster")
ggsave("./output/langexp/langexp_clust3_cluster.png")

```


##### Z-Mean Plots
```{r}
# Z-score effect Cluster results
hindi_groups %>% cbind(cluster3) %>% cbind(cluster8) %>% 
  cbind(langexp_scaled) %>% group_by(cluster3) %>% summarize(across(where(is.numeric), mean)) %>%
  pivot_longer(hear_child:last_col(), names_to = "variable", values_to = "z_score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=cluster3, y=z_score, fill=variable)) +
  geom_bar(stat="identity", position="dodge", alpha=0.8) +
  labs(subtitle="Cluster Z-Means", x="Cluster", y="Z-Score", color="Variable", fill="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))


ggsave("output/langexp/langexp_clust3_zmeans.png", width=12, height=7)
```

```{r}
# Z-score effect Cluster results
hindi_groups %>% cbind(cluster3) %>% cbind(cluster8) %>% 
  cbind(langexp_scaled) %>% group_by(cluster8) %>% summarize(across(where(is.numeric), mean)) %>%
  pivot_longer(hear_child:last_col(), names_to = "variable", values_to = "z_score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=z_score, fill=variable)) +
  geom_bar(stat="identity", position="dodge", alpha=0.8) +
  facet_wrap(~cluster8, ncol=8) +
  labs(subtitle="Cluster Z-Means", x="Cluster", y="Z-Score", color="Variable", fill="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))


ggsave("output/langexp/langexp_clust8_zmeans.png", width=12, height=7)
```

##### Mean Tables
```{r}

cluster_means3 <- langexp_final_data %>% group_by(cluster3) %>%
  mutate(cluster3 = case_when(cluster3 == 1 ~ "C",
                              cluster3 == 2 ~ "A",
                              cluster3 == 3 ~ "B"))  %>%
  summarize(across(where(is.numeric), mean)) #%>%
cluster_means3

cluster_means_table <- langexp_final_data %>% group_by(cluster3) %>%
  mutate(cluster3 = case_when(cluster3 == 1 ~ "C",
                              cluster3 == 2 ~ "A",
                              cluster3 == 3 ~ "B"))  %>%
  summarize(n=n(),
            across(where(is.numeric), mean)) %>% #%>% select(-cluster8)
  rename(Cluster = cluster3)
cluster_means_table

# print(xtable(cluster_means_table, type = "latex"), file = "clustermeans.tex")
```

```{r}
# cluster_means8 <- langexp_final_data %>% group_by(cluster8) %>%
#   summarize(across(where(is.numeric), mean)) %>% select(-cluster3)
# cluster_means8
```

##### Mean Plots
```{r}
cluster3.plt <- 
  cluster_means3 %>% 
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, fill=variable)) +
  geom_col(position="dodge", width=0.8, alpha=0.8) +
  facet_wrap(~cluster3) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))
cluster3.plt

ggsave("output/langexp/langexp_clust3_means_v2.png", width=12, height=7)
```

Cluster 1 = Low use of reading and writing now, but high comfort with all understand/speak/read/write
Cluster 2 = Lowest all scores, with highest comfort understanding and lowest use of reading/writing; lower speaking than hearing both growing up and now
Cluster 3 = High ratings overall, lowest being reading/writing use (still ~75)

```{r}
cluster8.plt <-
  cluster_means8 %>% 
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(cluster8 = factor(cluster8, levels = c("1", "3", "5", "7", "2", "4", "8", "6"))) %>%
  
  ggplot(aes(x=variable, y=score, fill=variable)) +
  geom_col(position="dodge", width=0.8, alpha=0.8) +
  facet_wrap(~cluster8, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))
cluster8.plt

ggsave("output/langexp/langexp_clust8_means.png", width=12, height=7)

```



##### Individual Plots
```{r}
# # Cluster results by individual
langexp_final_data %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%

  ggplot(aes(x=variable, y=score, fill=variable, color=variable, alpha=participant)) +
  geom_col(position="dodge", width=0.8) +
  facet_wrap(~cluster3, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))

ggsave("output/langexp/langexp_clust3_ind.png", width=12, height=7)


```


# .
## Part 2: Fine Tuning 
### Stage 4: Employing Non-Hierarchical Clustering

##### Run Clustering
```{r}
# Use random seed
set.seed(168)

# Run clustering
?kmeans
clust_km <- kmeans(dist(langexp_scaled), 4)

# Check details
clust_km$size
clust_km$cluster
clust_km$centers
```

#### Select Cluster Solutions
```{r}
# append cluster labels to original data
langexp_final_data_km <- 
  cbind(hindi_groups, cluster = clust_km$cluster) %>%
  cbind(langexp_scores) %>%
  cbind(langexp_scaled %>% rename_with(., ~ paste(.x, "z", sep="."))) %>%
  mutate(across(starts_with("cluster"), as.factor))

langexp_final_data_km
# View(langexp_final_data_km)
```


### Stage 5: Profiling Clustering Variable

#### Examine Cluster Distinctiveness
```{r}
summary(lm(hear_child ~ cluster, data=langexp_final_data_km))
summary(lm(speak_child ~ cluster, data=langexp_final_data_km))
summary(lm(hear_now ~ cluster, data=langexp_final_data_km))
summary(lm(speak_now ~ cluster, data=langexp_final_data_km))
summary(lm(read_now ~ cluster, data=langexp_final_data_km))
summary(lm(write_now ~ cluster, data=langexp_final_data_km))
summary(lm(comfort_understand ~ cluster, data=langexp_final_data_km))
summary(lm(comfort_speak ~ cluster, data=langexp_final_data_km))
summary(lm(comfort_readwrite ~ cluster, data=langexp_final_data_km))
```

#### Cluster Mean Tables
```{r}
cluster_means_km <- langexp_final_data_km %>% group_by(cluster) %>%
  mutate(cluster = case_when(cluster == 1 ~ "C",
                              cluster == 2 ~ "A",
                              cluster == 3 ~ "D",
                              cluster == 4 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child:comfort_readwrite, mean)) %>% 
  rename(Cluster = cluster)
cluster_means_km

cluster_zmeans_km <- langexp_final_data_km %>% group_by(cluster) %>%
  mutate(cluster = case_when(cluster == 1 ~ "C",
                              cluster == 2 ~ "A",
                              cluster == 3 ~ "D",
                              cluster == 4 ~ "B"))  %>%
  summarize(n=n(),
            across(hear_child.z:comfort_readwrite.z, mean)) %>% 
  rename(Cluster = cluster)
cluster_zmeans_km
```

#### Cluster Mean Plots
```{r, error=FALSE}
# Cluster mean Bar plots faceted by Cluster
cluster_means_km %>% 
  
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, fill=variable)) +
  geom_col(position="dodge", width=0.8, alpha=0.8) +
  facet_wrap(~Cluster, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# Cluster individual bar plots faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(cluster = case_when(cluster == 1 ~ "C",
                              cluster == 2 ~ "A",
                              cluster == 3 ~ "D",
                              cluster == 4 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, fill=variable, color=variable, alpha=participant)) +
  geom_col(position="dodge", width=0.8) +
  facet_wrap(~cluster, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))


# Cluster individual line graphs faceted by Cluster 
langexp_final_data %>%
  pivot_longer(hear_child:comfort_readwrite, names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(cluster = case_when(cluster == 1 ~ "C",
                              cluster == 2 ~ "A",
                              cluster == 3 ~ "D",
                              cluster == 4 ~ "B"))  %>%

  ggplot(aes(x=variable, y=score, color=cluster, group=participant)) +
  geom_point(alpha=0.5) +
  geom_line(alpha=0.5) +
  facet_wrap(~cluster, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# Cluster mean line graph comparing across clusters
cluster_means_km %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point() +
  geom_line() +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))

# Cluster Z-mean (relative) line graph comparing across clusters
cluster_zmeans_km %>%
  pivot_longer(hear_child.z:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child.z", "speak_child.z", "hear_now.z", "speak_now.z", "read_now.z", "write_now.z", "comfort_understand.z", "comfort_speak.z", "comfort_readwrite.z"))) %>%
  
  ggplot(aes(x=variable, y=score, color=Cluster, group=Cluster)) +
  geom_point() +
  geom_line() +
  labs(x="Variables", y="Mean Rating Score", color="Cluster") +
  gg_theme() +
  scale_fill_brewer(palette = "Set2") + 
  scale_color_brewer(palette = "Set2") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  # theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  # theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  # theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=20)) +
  theme(axis.title=element_text(size=25),
        axis.text=element_text(size=20),
        strip.text = element_text(size=25)) +
  theme(legend.title = element_text(size=25, face="bold"),
        legend.text=element_text(size=20))
```


##### Validate (Internal)
###### Assess Number of Clusters
```{r}
# Elbow method
fviz_nbclust(langexp_scaled, kmeans, method = "wss", k.max = 10) +
  labs(subtitle = "Elbow method")

fviz_nbclust(langexp_scaled, hcut, method = "wss", k.max = 10) +
  labs(subtitle = "Elbow method")

# Silhouette method

fviz_nbclust(langexp_scaled, hcut, method = "silhouette", k.max = 10) +
  labs(subtitle = "Silhouette method")

# Gap statistic
# nboot = 50 to keep the function speedy. 
# recommended value: nboot= 500 for your analysis.
# Use verbose = FALSE to hide computing progression.
set.seed(123)
fviz_nbclust(langexp_scaled, kmeans, nstart = 25,  method = "gap_stat", nboot = 50, k.max = 10)+
  labs(subtitle = "Gap statistic method")

#calculate gap statistic for each number of clusters (up to 10 clusters)
gap_stat <- clusGap(langexp_scaled, FUN = hcut, nstart = 25, K.max = 10, B = 50)

#produce plot of clusters vs. gap statistic
fviz_gap_stat(gap_stat)
```


```{r}
# NbClust(langexp_scaled, distance="euclidean", min.nc=2, max.nc=10, method="kmeans", index="all")
```


```{r}
# Silhouette Plot
# A large value (close to 1) represents good clustering; Close to -1 means bad (wrong cluster)
sil <- silhouette(clust_km$cluster, dist(langexp_scaled))
fviz_silhouette(sil, palette="jco") + theme_bw()
```

```{r}
# Dunn Index
# A large Dunn index reprsents good clustering (min.separation/max.diamenter)
km.stats <- cluster.stats(dist(langexp_scaled), clust_km$cluster)
km.stats$dunn
```

##### Validate (External)
```{r}
# K-means to Hierarchical

# How well do clusters match?
clust.stats <- cluster.stats(d = dist(langexp_scaled), clust_km$cluster, cluster3)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(native_groups,cluster3)
```

```{r}
# 3-cluster v. Native

# How well do clusters match group structure?
native_groups <- as.numeric(as.factor(hindi_groups$native_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), native_groups,clust_km$cluster)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(native_groups,clust_km$cluster)
```

```{r}
# 3-cluster v. Residence

# How well do clusters match group structure?
residence_groups <- as.numeric(as.factor(hindi_groups$residence_group)) 
clust.stats <- cluster.stats(d = dist(langexp_scaled), residence_groups,clust_km$cluster)

# Corrected Rand Index
# Between 0 and 1, should be maximized (close to 1)
clust.stats$corrected.rand

# Meila's Variation of Information (VI)
# Closely related to mutual information. Should be minimized
clust.stats$vi

# Normalized Variation of Information (NVI) --- between 0 and 1
## NVI is zero if the partitions are identical and one if they are statistically independent, meaning no information is gained about C by knowing C′ and vice versa (Esmailian & Jaili, 2015)
aricode::NVI(residence_groups,clust_km$cluster)
```



```{r}
langexp_final_data %>%
  pivot_longer(hear_child:last_col(), names_to="variable", values_to="score") %>%
  mutate(variable = factor(variable, levels = c("hear_child", "speak_child", "hear_now", "speak_now", "read_now", "write_now", "comfort_understand", "comfort_speak", "comfort_readwrite"))) %>%
  mutate(cluster8 = factor(cluster8, levels = c("1", "3", "5", "7", "2", "4", "8", "6"))) %>%

  ggplot(aes(x=variable, y=score, fill=variable, color=variable, alpha=participant)) +
  geom_col(position="dodge", width=0.8) +
  facet_wrap(~cluster8, ncol=4) +
  labs(x="Cluster", y="Mean Rating Score", fill="Variable", color="Variable") +
  scale_alpha_discrete(guide = "none") +
  gg_theme() +
  scale_fill_brewer(palette = "Paired") + 
  scale_color_brewer(palette = "Paired") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  theme(legend.position = "bottom", legend.key.size = unit(.5, "cm"), legend.text = element_text(size=15))

ggsave("output/langexp/langexp_clust8_ind.png", width=12, height=7)

```




